# **Python Revision Guide: Object-Oriented Programming (OOP) ğŸš€**

OOP is a programming paradigm based on **objects** that contain **attributes (data)** and  **methods (functions)** .

âœ… **Class & Object**

âœ… **Encapsulation**

âœ… **Inheritance**

âœ… **Polymorphism**

âœ… **Abstraction**

âœ… **Magic Methods & Property Decorators**

---

## **1. Classes & Objects (Basics of OOP)**

A **class** is a blueprint for creating objects.

An **object** is an instance of a class.

### **1.1 Defining a Class & Creating an Object**

```python
class Car:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

    def display_info(self):
        return f"Car: {self.brand} {self.model}"

# Creating Objects
car1 = Car("Toyota", "Camry")
print(car1.display_info())  # Car: Toyota Camry
```

ğŸ”¹ **Diagram (Class & Object Structure)**

```
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Class: Car  â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ brand        â”‚
  â”‚ model        â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ display_info â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
          â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Object: car1  â”‚
  â”‚ Toyota Camry  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## **2. Encapsulation (Data Hiding)**

Encapsulation restricts **direct access** to variables and methods.

### **2.1 Private Variables (`__var`)**

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # Private variable

    def deposit(self, amount):
        self.__balance += amount

    def get_balance(self):
        return self.__balance

account = BankAccount(1000)
account.deposit(500)
print(account.get_balance())  # 1500
# print(account.__balance)  # AttributeError: 'BankAccount' object has no attribute '__balance'
```

ğŸ”¹ **Encapsulation Prevents Direct Access**

```
Class: BankAccount
   â”œâ”€â”€ __balance (Private)
   â”œâ”€â”€ deposit(amount)
   â”œâ”€â”€ get_balance()
```

---

## **3. Inheritance (Code Reusability)**

Inheritance allows one class ( **child class** ) to acquire properties of another class ( **parent class** ).

### **3.1 Single Inheritance**

```python
class Vehicle:
    def __init__(self, brand):
        self.brand = brand

    def show_brand(self):
        return f"Brand: {self.brand}"

class Car(Vehicle):  # Inheriting from Vehicle
    def __init__(self, brand, model):
        super().__init__(brand)  # Call parent constructor
        self.model = model

    def show_details(self):
        return f"{self.show_brand()}, Model: {self.model}"

car = Car("Tesla", "Model 3")
print(car.show_details())  # Brand: Tesla, Model: Model 3
```

ğŸ”¹ **Inheritance Diagram**

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Vehicle   â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ brand      â”‚
        â”‚ show_brand â”‚
        â””â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”˜
              â”‚
       â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
       â”‚   Car      â”‚
       â”‚ model      â”‚
       â”‚ show_details â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **3.2 Multiple Inheritance**

```python
class Engine:
    def engine_type(self):
        return "Electric"

class Car(Vehicle, Engine):
    pass

car = Car("BMW")
print(car.show_brand())  # Brand: BMW
print(car.engine_type())  # Electric
```

---

## **4. Polymorphism (Method Overriding)**

Polymorphism allows different classes to have the **same method name** but different implementations.

```python
class Animal:
    def sound(self):
        return "Some sound"

class Dog(Animal):
    def sound(self):
        return "Bark"

class Cat(Animal):
    def sound(self):
        return "Meow"

animals = [Dog(), Cat()]

for animal in animals:
    print(animal.sound())
# Bark
# Meow
```

ğŸ”¹ **Polymorphism Diagram**

```
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚  Animal      â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ sound()      â”‚
      â””â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”˜
        â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
        â”‚          â”‚
    â”Œâ”€â”€â–¼â”€â”€â”    â”Œâ”€â”€â–¼â”€â”€â”
    â”‚ Dog â”‚    â”‚ Cat â”‚
    â”œâ”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”¤
    â”‚ Barkâ”‚    â”‚ Meowâ”‚
    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜
```

---

## **5. Abstraction (Hiding Implementation)**

Abstraction hides implementation details and enforces method definitions in subclasses.

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

circle = Circle(5)
print(circle.area())  # 78.5
```

ğŸ”¹ **Abstraction Diagram**

```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Shape (ABC)â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ area()      â”‚
   â””â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”˜
          â”‚
   â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
   â”‚  Circle    â”‚
   â”‚ area()     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## **6. Magic Methods & Property Decorators**

### **6.1 Magic Methods (`__str__`, `__add__`, etc.)**

```python
class Book:
    def __init__(self, title, pages):
        self.title = title
        self.pages = pages

    def __str__(self):
        return f"Book: {self.title}, Pages: {self.pages}"

    def __add__(self, other):
        return self.pages + other.pages

book1 = Book("Python 101", 200)
book2 = Book("AI Basics", 300)

print(book1)  # Book: Python 101, Pages: 200
print(book1 + book2)  # 500
```

ğŸ”¹ **Common Magic Methods**

| Magic Method | Purpose               |
| ------------ | --------------------- |
| `__init__` | Constructor           |
| `__str__`  | String representation |
| `__add__`  | Adds objects          |
| `__len__`  | Returns length        |
| `__eq__`   | Compares objects      |

---

### **6.2 Property Decorators (`@property`)**

```python
class Employee:
    def __init__(self, name, salary):
        self.name = name
        self._salary = salary

    @property
    def salary(self):
        return self._salary

    @salary.setter
    def salary(self, amount):
        if amount < 0:
            raise ValueError("Salary can't be negative")
        self._salary = amount

emp = Employee("Alice", 5000)
print(emp.salary)  # 5000
emp.salary = 6000  # Setter is called
```

---

## **ğŸ“Œ Summary & Performance Notes**

âœ… **Encapsulation** â†’ Hides data (`__var`)

âœ… **Inheritance** â†’ Reuse code (`super()`)

âœ… **Polymorphism** â†’ Same method, different classes (`method overriding`)

âœ… **Abstraction** â†’ Define abstract classes (`@abstractmethod`)

âœ… **Magic Methods** â†’ Customize class behavior (`__str__`, `__add__`)

âœ… **Property Decorators** â†’ Control attributes (`@property`)
